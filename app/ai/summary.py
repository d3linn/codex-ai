"""Summarization utilities backed by the OpenAI API."""

from __future__ import annotations

import asyncio
import importlib
from typing import Any, Protocol

from app.core.logging import get_logger


logger = get_logger(name=__name__)


class SummarizationService(Protocol):
    """Interface defining the contract for text summarization services."""

    async def summarize(self, text: str) -> str:
        """Return a concise summary for the provided text.

        Args:
            text: Body of text that should be summarized.

        Returns:
            str: Concise summary generated for the supplied text.
        """


class OpenAISummarizationService:
    """Summarization service that delegates to OpenAI's GPT-5 model."""

    def __init__(self, api_key: str, *, client: Any | None = None) -> None:
        """Initialize the service with the provided API credentials.

        Args:
            api_key: Secret key used to authenticate against OpenAI's API.
            client: Optional preconfigured OpenAI client, primarily used for testing.

        Raises:
            ValueError: If the API key is missing or blank.
            RuntimeError: If the OpenAI SDK is unavailable in the runtime environment.
        """
        if not api_key or not api_key.strip():
            raise ValueError("OPENAI_API_KEY must be configured")
        self._client: Any
        if client is not None:
            self._client = client
            return

        try:
            openai_module = importlib.import_module("openai")
        except ModuleNotFoundError as exc:  # pragma: no cover - exercised via configuration
            raise RuntimeError("openai package is not installed") from exc

        openai_client = getattr(openai_module, "OpenAI", None)
        if openai_client is None:
            raise RuntimeError("OpenAI client is unavailable")
        self._client = openai_client(api_key=api_key)

    async def summarize(self, text: str) -> str:
        """Summarize the provided text using the GPT-5 model.

        Args:
            text: Source text that should be summarized.

        Returns:
            str: Concise summary generated by the language model.

        Raises:
            ValueError: If the provided text is empty.
            RuntimeError: If the API call fails or the response cannot be parsed.
        """
        if not text or not text.strip():
            raise ValueError("Text must not be empty")

        def _invoke() -> str:
            """Invoke the OpenAI Responses API synchronously.

            Returns:
                str: Summary text returned by the OpenAI Responses API.

            Raises:
                RuntimeError: If the API request fails.
            """
            try:
                response = self._client.responses.create(
                    model="gpt-5",
                    input=[
                        {"role": "system", "content": "You are a concise summarization assistant."},
                        {"role": "user", "content": text},
                    ],
                    max_output_tokens=400,
                )
            except Exception as exc:  # pragma: no cover - network failures not exercised in tests
                logger.error("openai_request_failed", error=str(exc))
                raise RuntimeError("Failed to generate summary") from exc
            summary = _extract_summary_text(response)
            if not summary:
                raise RuntimeError("Received empty summary from OpenAI")
            return summary

        summary = await asyncio.to_thread(_invoke)
        logger.info("summarize_success", text_length=len(text), summary_length=len(summary))
        return summary


def _extract_summary_text(response: Any) -> str:
    """Extract textual content from an OpenAI responses payload.

    Args:
        response: Arbitrary object returned by the OpenAI SDK.

    Returns:
        str: Extracted summary text or an empty string when unavailable.
    """
    output = getattr(response, "output", None)
    if isinstance(output, list):
        chunks: list[str] = []
        for block in output:
            content = getattr(block, "content", None)
            if isinstance(content, list):
                for item in content:
                    text = getattr(item, "text", None)
                    if isinstance(text, str):
                        chunks.append(text)
        if chunks:
            return "".join(chunks).strip()

    choices = getattr(response, "choices", None)
    if isinstance(choices, list) and choices:
        first = choices[0]
        message = getattr(first, "message", None)
        if isinstance(message, dict):
            content = message.get("content")
            if isinstance(content, str):
                return content.strip()

    if hasattr(response, "model_dump"):
        data = response.model_dump()
        if isinstance(data, dict):
            content = data.get("output_text") or data.get("text")
            if isinstance(content, str):
                return content.strip()

    return ""
